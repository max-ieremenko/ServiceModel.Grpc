// <copyright>
// Copyright 2020-2024 Max Ieremenko
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//  http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// </copyright>

using System;
using System.Collections.Immutable;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using ServiceModel.Grpc.DesignTime.Generator.Internal.CSharp;

namespace ServiceModel.Grpc.DesignTime.Generator;

internal readonly ref struct CompilationUnit
{
    private readonly IDisposable[] _indentation;

    public CompilationUnit(ClassDeclarationSyntax node)
    {
        Output = new CodeStringBuilder();

        AddComment(Output);
        AddUsing(Output);
        _indentation = DeclareClass(node, Output);
    }

    public CodeStringBuilder Output { get; }

    public string GetSourceText()
    {
        for (var i = 0; i < _indentation.Length; i++)
        {
            _indentation[i].Dispose();
            Output.AppendLine("}");
        }

        var text = Output.AsStringBuilder();
        return text.ToString();
    }

    private static void AddComment(CodeStringBuilder output)
    {
        var comment = @"// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

"
            .Replace("\r\n", "\n")
            .Replace("\n", Environment.NewLine);

        output.Append(comment);
    }

    private static void AddUsing(CodeStringBuilder output)
    {
        output.AppendLine("using System;");
        output.AppendLine("using System.Collections.Generic;");
        output.AppendLine("using System.Threading;");
        output.AppendLine("using System.Threading.Tasks;");
        output.AppendLine();
    }

    private static IDisposable[] DeclareClass(ClassDeclarationSyntax node, CodeStringBuilder output)
    {
        var owners = ImmutableArray<string>.Empty;

        foreach (var ancestor in node.AncestorMembers())
        {
            if (ancestor.Kind == SyntaxKind.NamespaceDeclaration)
            {
                owners = owners.Insert(0, "namespace " + ancestor.Name);
            }
            else
            {
                owners = owners.Insert(0, "partial class " + ancestor.Name);
            }
        }

        owners = owners.Add("partial class " + node.Identifier.WithoutTrivia());

        var result = new IDisposable[owners.Length];
        for (var i = 0; i < owners.Length; i++)
        {
            output
                .AppendLine(owners[i])
                .AppendLine("{");

            result[i] = output.Indent();
        }

        return result;
    }
}